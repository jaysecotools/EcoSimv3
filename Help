<script>
    // COMPLETELY FIXED VERSION - The simulation now works properly!
    document.addEventListener('DOMContentLoaded', function() {
      // Make sure all DOM elements are ready
      setTimeout(() => {
        const ecosystemSimulator = function(p) {
          // Global Variables - properly initialized with correct values
          let grass = 600;
          let pademelons = 80;
          let devils = 25;
          let bandicoots = 40;
          let chart;
          let season = 0; // 0: Spring, 1: Summer, 2: Autumn, 3: Winter
          let seasonDuration = 300;
          let showSeasons = true;
          let showDisasters = true;
          let disasterDuration = 100;
          let disasterFrame = -disasterDuration;
          let isPaused = false;
          let grassLimitEnabled = true;
          let points = 0;
          let stabilityCheckFrames = 0;
          const stabilityThreshold = 1000;
          const stabilityPoints = 50;
          const rangerBadgePoints = 1500;
          let rangerBadgeAchieved = false;

          // Speed control
          let speedMultiplier = 1;
          let lastFrameTime = performance.now();
          let customFrameCount = 0;

          // Ecological metrics
          let biodiversityIndex = 0;
          let ecosystemHealth = 100;

          // Particle effects
          let grassParticles = [];
          let pademelonParticles = [];
          let devilParticles = [];
          let bandicootParticles = [];

          // Learning objectives
          let objectives = [
            { 
              description: "Increase pademelon population to 150", 
              target: 150, 
              achieved: false, 
              points: 200, 
              type: "pademelons" 
            },
            { 
              description: "Maintain devil population > 60 with grass > 300", 
              target: 60, 
              achieved: false, 
              points: 300, 
              type: "apex_stability" 
            },
            { 
              description: "Trigger bandicoot-driven grass recovery (reach 300 grass)", 
              target: 300, 
              achieved: false, 
              points: 200, 
              type: "keystone_effect" 
            },
            { 
              description: "Survive 5 natural disasters", 
              target: 5, 
              achieved: false, 
              points: 100, 
              count: 0, 
              type: "disasters" 
            },
            { 
              description: "Maintain biodiversity index > 0.6 for 500 frames", 
              target: 500, 
              achieved: false, 
              points: 150, 
              type: "biodiversity" 
            }
          ];

          let ongoingObjectives = [
            { 
              description: "Keep grass population > 700 for 800 frames", 
              target: 800, 
              achieved: false, 
              points: 300, 
              type: "grass", 
              condition: (g) => g > 700 
            },
            { 
              description: "Keep devil population > 50 for 800 frames", 
              target: 800, 
              achieved: false, 
              points: 300, 
              type: "devils", 
              condition: (d) => d > 50 
            },
            { 
              description: "Maintain balanced ecosystem for 1500 frames", 
              target: 1500, 
              achieved: false, 
              points: 500, 
              type: "balanced", 
              condition: (g, p, d, b) => g > 400 && p > 60 && d > 25 && b > 30 
            }
          ];

          let achievements = [
            { 
              description: "Ecosystem Guardian: Achieve all ongoing objectives", 
              achieved: false, 
              points: 500 
            },
            { 
              description: "Devil Advocate: Maintain healthy devil population for 5000 frames", 
              achieved: false, 
              frames: 0, 
              target: 5000, 
              points: 300 
            },
            { 
              description: "Keystone Keeper: Double bandicoot population from starting value", 
              achieved: false, 
              target: 80, 
              points: 200 
            }
          ];

          let populationHistory = [];
          const historyLength = 200;

          // Seasonal parameters
          let seasonParams = [
            { name: "Spring", rainfall: 70, temperature: 20, color: "#d4f1f4" },
            { name: "Summer", rainfall: 30, temperature: 35, color: "#f7d794" },
            { name: "Autumn", rainfall: 50, temperature: 15, color: "#f5cd79" },
            { name: "Winter", rainfall: 40, temperature: 5, color: "#c8d6e5" }
          ];

          // Interpolation variables
          let targetRainfall = 70;
          let targetTemperature = 20;
          let currentRainfall = 70;
          let currentTemperature = 20;
          const interpolationSpeed = 0.01;

          // DOM Elements
          let disasterMessage, seasonDisplay, pointsDisplay, objectiveDisplay;
          let grassValue, pademelonsValue;
          let devilsValue, bandicootsValue, healthStatus, healthText;
          let progressBar, progressText;

          p.setup = function() {
            // Initialize p5.js canvas
            let canvas = p.createCanvas(800, 300);
            canvas.parent("canvas-container");
            
            // Initialize chart
            initChart();
            
            // Get DOM elements with error handling
            disasterMessage = document.getElementById('disasterMessage');
            seasonDisplay = document.getElementById('seasonDisplay');
            pointsDisplay = document.getElementById('pointsDisplay');
            objectiveDisplay = document.getElementById('objectiveDisplay');
            grassValue = document.getElementById('grass-value');
            pademelonsValue = document.getElementById('pademelons-value');
            devilsValue = document.getElementById('devils-value');
            bandicootsValue = document.getElementById('bandicoots-value');
            healthStatus = document.getElementById('healthStatus');
            healthText = document.getElementById('healthText');
            progressBar = document.getElementById('progressBar');
            progressText = document.getElementById('progressText');
            
            // Set up controls
            initControls();
            
            // Set up species card interactions
            document.querySelectorAll('.species-card').forEach(card => {
              card.addEventListener('click', function() {
                this.classList.toggle('expanded');
              });
            });
            
            // Reset simulation to starting state
            resetSim();
            
            // Start the game loop
            p.loop();
          };

          p.draw = function() {
            // Handle speed control
            const now = performance.now();
            const deltaTime = now - lastFrameTime;
            lastFrameTime = now;
            
            // Only update when not paused
            if (!isPaused) {
              // Update based on speed multiplier - CRITICAL FIX: ensure we always update at least once
              for (let i = 0; i < Math.max(1, speedMultiplier); i++) {
                update();
                customFrameCount++;
              }
            }
            
            // Always draw (even when paused) for smooth animations
            drawVisualization();
          };

          // Initialize the population chart
          function initChart() {
            const ctx = document.getElementById('populationChart').getContext('2d');
            chart = new Chart(ctx, {
              type: 'line',
              data: {
                labels: [],
                datasets: [
                  { 
                    label: "Grass", 
                    data: [], 
                    borderColor: "#4CAF50", 
                    backgroundColor: "rgba(76, 175, 80, 0.1)",
                    fill: true,
                    tension: 0.4
                  },
                  { 
                    label: "Pademelons", 
                    data: [], 
                    borderColor: "#FF9800", 
                    backgroundColor: "rgba(255, 152, 0, 0.1)",
                    fill: true,
                    tension: 0.4
                  },
                  { 
                    label: "Devils", 
                    data: [], 
                    borderColor: "#F44336", 
                    backgroundColor: "rgba(244, 67, 54, 0.1)",
                    fill: true,
                    tension: 0.4
                  },
                  { 
                    label: "Bandicoots", 
                    data: [], 
                    borderColor: "#FFEB3B", 
                    backgroundColor: "rgba(255, 235, 59, 0.1)",
                    fill: true,
                    tension: 0.4
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                  duration: 0
                },
                plugins: {
                  legend: {
                    position: 'top',
                    labels: {
                      boxWidth: 12,
                      padding: 20,
                      font: {
                        size: 12
                      }
                    }
                  },
                  tooltip: {
                    mode: 'index',
                    intersect: false
                  }
                },
                scales: {
                  x: {
                    grid: {
                      display: false
                    },
                    ticks: {
                      maxRotation: 0,
                      autoSkip: true,
                      maxTicksLimit: 10
                    }
                  },
                  y: {
                    beginAtZero: true,
                    grid: {
                      color: 'rgba(0,0,0,0.05)'
                    }
                  }
                },
                elements: {
                  point: {
                    radius: 0,
                    hoverRadius: 5
                  }
                }
              }
            });
          }

          // Set up control event listeners
          function initControls() {
            // Speed control
            const speedSlider = document.getElementById("speedSlider");
            const speedValue = document.getElementById("speedValue");
            if (speedSlider) {
              speedSlider.addEventListener("input", () => {
                speedMultiplier = parseFloat(speedSlider.value);
                if (speedValue) speedValue.textContent = speedMultiplier.toFixed(1) + "x";
              });
            }

            // Slider value updates
            document.querySelectorAll("input[type='range']").forEach(slider => {
              slider.addEventListener("input", function() {
                const valueSpan = document.getElementById(this.id + 'Value');
                if (valueSpan) {
                  valueSpan.textContent = this.value;
                }
              });
            });

            // Button controls
            const resetBtn = document.getElementById("resetButton");
            if (resetBtn) resetBtn.addEventListener("click", resetSim);
            
            const pauseBtn = document.getElementById("pauseButton");
            if (pauseBtn) pauseBtn.addEventListener("click", togglePause);
            
            // Toggle switches
            const seasonsToggle = document.getElementById("toggleSeasons");
            if (seasonsToggle) seasonsToggle.addEventListener("change", toggleSeasonsDisplay);
            
            const disastersToggle = document.getElementById("toggleDisasters");
            if (disastersToggle) disastersToggle.addEventListener("change", toggleDisasters);
            
            const grassLimitToggle = document.getElementById("toggleGrassLimit");
            if (grassLimitToggle) grassLimitToggle.addEventListener("change", toggleGrassLimit);

            // Tab navigation
            document.querySelectorAll(".tab-btn").forEach(btn => {
              btn.addEventListener("click", () => {
                document.querySelectorAll(".tab-btn").forEach(b => b.classList.remove("active"));
                document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
                
                btn.classList.add("active");
                const tabId = `${btn.dataset.tab}-tab`;
                const tabElement = document.getElementById(tabId);
                if (tabElement) tabElement.classList.add("active");
              });
            });
          }

          // Main update function - CRITICAL FIX: ensure all updates happen correctly
          function update() {
            // Seasonal changes
            updateSeasons();
            
            // Get environmental factors with error handling
            let rainfallSlider = document.getElementById("rainfall");
            let tempSlider = document.getElementById("temperature");
            let invasiveSlider = document.getElementById("invasiveSpecies");
            let humanSlider = document.getElementById("humanImpact");
            
            const rainfall = getModifiedRainfall(rainfallSlider ? parseFloat(rainfallSlider.value) : 50);
            const temperature = getModifiedTemperature(tempSlider ? parseFloat(tempSlider.value) : 25);
            const invasiveSpecies = invasiveSlider ? parseFloat(invasiveSlider.value) : 5;
            const humanImpact = humanSlider ? parseFloat(humanSlider.value) : 2;
            
            // Update populations with balanced dynamics - CRITICAL FIX: ensure values are numbers
            updateGrass(rainfall, invasiveSpecies);
            updatePademelons(temperature, humanImpact, invasiveSpecies);
            updateBandicoots(temperature, invasiveSpecies, humanImpact);
            updateDevils(humanImpact, temperature);
            
            // Apply gentle population limits
            applyLimits();
            
            // Update particle effects
            updateParticles();
            
            // Track history
            updateHistory();
            
            // Check for events and objectives
            checkRandomEvents();
            checkObjectives();
            updateEcosystemMetrics();
            
            // Update displays
            updateSpeciesDisplays();
            updateUI();
          }

          // Update seasonal changes
          function updateSeasons() {
            if (showSeasons) {
              if (customFrameCount % seasonDuration === 0) {
                season = (season + 1) % 4;
                if (seasonDisplay) seasonDisplay.textContent = seasonParams[season].name;
                targetRainfall = seasonParams[season].rainfall;
                targetTemperature = seasonParams[season].temperature;
              }
              
              // Smooth seasonal transitions
              currentRainfall += (targetRainfall - currentRainfall) * interpolationSpeed;
              currentTemperature += (targetTemperature - currentTemperature) * interpolationSpeed;
            } else {
              // When seasons are off, maintain baseline conditions
              if (seasonDisplay) seasonDisplay.textContent = "None";
              targetRainfall = 50;
              targetTemperature = 25;
              currentRainfall = targetRainfall;
              currentTemperature = targetTemperature;
            }
          }

          // Get modified rainfall value
          function getModifiedRainfall(sliderValue) {
            const rainfallSlider = sliderValue - 50;
            return Math.max(0, Math.min(100, currentRainfall + rainfallSlider));
          }

          // Get modified temperature value
          function getModifiedTemperature(sliderValue) {
            const tempSlider = sliderValue - 25;
            return Math.max(0, Math.min(50, currentTemperature + tempSlider));
          }

          // Update grass population - CRITICAL FIX: ensure calculations work with numbers
          function updateGrass(rainfall, invasiveSpecies) {
            // Base growth - grass grows quickly with good rainfall
            const rainfallFactor = 0.5 + (rainfall / 100); // 0.5 to 1.5
            
            // Bandicoots help grass grow (up to 50% boost)
            const bandicootBoost = 1 + (bandicoots / 400); // Max 1.75 with 300 bandicoots
            
            // Natural growth (5-15% per frame)
            const growth = grass * 0.08 * rainfallFactor * bandicootBoost;
            
            // Grazing by pademelons (each pademelon eats some grass)
            const grazing = pademelons * 0.5;
            
            // Invasive species compete with grass
            const invasiveEffect = invasiveSpecies * 2;
            
            // Update grass
            grass = grass + growth - grazing - invasiveEffect;
            
            // Apply limits
            if (grassLimitEnabled) {
              grass = Math.min(grass, 1500);
            } else {
              grass = Math.min(grass, 2500);
            }
            grass = Math.max(grass, 50); // Keep minimum grass
            
            // Particle effects
            if (growth > grazing && Math.random() < 0.05) {
              grassParticles.push({
                x: p.random(p.width),
                y: p.height/2,
                size: p.random(5, 10),
                life: 100,
                vx: p.random(-1, 1),
                vy: p.random(-2, -1),
                color: [76, 175, 80]
              });
            }
          }

          // Update pademelon population
          function updatePademelons(temperature, humanImpact, invasiveSpecies) {
            // Food availability - more grass means more pademelons
            const foodFactor = Math.min(2, Math.max(0.5, grass / 400)); // 0.5 to 2.0
            
            // Natural growth rate
            const births = pademelons * 0.06 * foodFactor;
            
            // Deaths from various causes
            const predation = devils * 0.3; // Each devil eats some pademelons
            const tempStress = Math.abs(temperature - 20) * 0.5;
            const hunting = humanImpact * 1.5;
            const invasiveCompetition = invasiveSpecies * 1;
            const naturalDeaths = pademelons * 0.02;
            
            // Update pademelons
            pademelons = pademelons + births - predation - tempStress - hunting - invasiveCompetition - naturalDeaths;
            
            // Keep within reasonable bounds
            pademelons = Math.min(pademelons, 400);
            pademelons = Math.max(pademelons, 20);
            
            // Particle effects
            if (births > predation && Math.random() < 0.03) {
              pademelonParticles.push({
                x: p.random(p.width),
                y: p.height/2,
                size: p.random(8, 12),
                life: 100,
                vx: p.random(-1, 1),
                vy: p.random(-1, 0),
                color: [255, 152, 0]
              });
            }
          }

          // Update bandicoot population
          function updateBandicoots(temperature, invasiveSpecies, humanImpact) {
            // Bandicoots benefit from grass but compete with pademelons
            const foodFactor = Math.min(2, Math.max(0.5, grass / 300));
            const competition = pademelons * 0.1;
            
            // Natural growth
            const births = bandicoots * 0.05 * foodFactor;
            
            // Deaths
            const predation = devils * 0.15;
            const tempStress = Math.abs(temperature - 22) * 0.4;
            const hunting = humanImpact * 1;
            const invasiveEffect = invasiveSpecies * 0.8;
            const naturalDeaths = bandicoots * 0.02;
            
            // Update bandicoots
            bandicoots = bandicoots + births - predation - tempStress - hunting - invasiveEffect - competition - naturalDeaths;
            
            // Keep within bounds
            bandicoots = Math.min(bandicoots, 300);
            bandicoots = Math.max(bandicoots, 15);
            
            // Particle effects
            if (births > predation && Math.random() < 0.02) {
              bandicootParticles.push({
                x: p.random(p.width),
                y: p.height/2,
                size: p.random(6, 10),
                life: 100,
                vx: p.random(-0.5, 0.5),
                vy: p.random(-0.5, 0.5),
                color: [255, 235, 59]
              });
            }
          }

          // Update devil population
          function updateDevils(humanImpact, temperature) {
            // Food availability based on prey
            const preyTotal = pademelons + bandicoots;
            const foodFactor = Math.min(2, Math.max(0.5, preyTotal / 150));
            
            // Natural growth - devils reproduce slowly
            const births = devils * 0.03 * foodFactor;
            
            // Deaths
            const starvation = devils * (1 - Math.min(1, preyTotal / 100)) * 0.1;
            const tempStress = Math.abs(temperature - 18) * 0.3;
            const hunting = humanImpact * 0.8;
            const naturalDeaths = devils * 0.02;
            
            // Update devils
            devils = devils + births - starvation - tempStress - hunting - naturalDeaths;
            
            // Carrying capacity based on prey
            const maxDevils = (pademelons * 0.2) + (bandicoots * 0.1);
            devils = Math.min(devils, Math.max(10, maxDevils));
            
            // Keep minimum population
            devils = Math.max(devils, 5);
            
            // Particle effects
            if (births > naturalDeaths && Math.random() < 0.01) {
              devilParticles.push({
                x: p.random(p.width),
                y: p.height/2,
                size: p.random(10, 15),
                life: 100,
                vx: p.random(-0.5, 0.5),
                vy: p.random(-0.5, 0.5),
                color: [244, 67, 54]
              });
            }
          }

          // Apply gentle population limits
          function applyLimits() {
            grass = Math.min(grass, grassLimitEnabled ? 1500 : 2500);
            grass = Math.max(grass, 50);
            
            pademelons = Math.min(pademelons, 400);
            pademelons = Math.max(pademelons, 15);
            
            devils = Math.min(devils, 120);
            devils = Math.max(devils, 3);
            
            bandicoots = Math.min(bandicoots, 300);
            bandicoots = Math.max(bandicoots, 10);
          }

          // Update population history and chart
          function updateHistory() {
            populationHistory.push({
              frame: customFrameCount,
              grass: grass,
              pademelons: pademelons,
              devils: devils,
              bandicoots: bandicoots
            });
            
            if (populationHistory.length > historyLength) {
              populationHistory.shift();
            }
            
            if (chart) {
              chart.data.labels.push(customFrameCount);
              chart.data.datasets[0].data.push(grass);
              chart.data.datasets[1].data.push(pademelons);
              chart.data.datasets[2].data.push(devils);
              chart.data.datasets[3].data.push(bandicoots);
              
              if (chart.data.labels.length > 100) {
                chart.data.labels.shift();
                chart.data.datasets.forEach(dataset => dataset.data.shift());
              }
              
              chart.update();
            }
          }

          // Update particle effects
          function updateParticles() {
            grassParticles = grassParticles.filter(p => {
              p.x += p.vx;
              p.y += p.vy;
              p.life--;
              return p.life > 0;
            });
            
            pademelonParticles = pademelonParticles.filter(p => {
              p.x += p.vx;
              p.y += p.vy;
              p.life--;
              return p.life > 0;
            });
            
            devilParticles = devilParticles.filter(p => {
              p.x += p.vx;
              p.y += p.vy;
              p.life--;
              return p.life > 0;
            });
            
            bandicootParticles = bandicootParticles.filter(p => {
              p.x += p.vx;
              p.y += p.vy;
              p.life--;
              return p.life > 0;
            });
          }

          // Check for random events
          function checkRandomEvents() {
            if (showDisasters && customFrameCount > 0 && customFrameCount % 1000 === 0 && Math.random() < 0.3) {
              triggerRandomEvent();
            }
            
            if (customFrameCount > 0 && customFrameCount % 750 === 0) {
              triggerNarrativeEvent();
            }
          }

          // Trigger random ecosystem event
          function triggerRandomEvent() {
            const events = [
              { 
                name: "Bushfire", 
                effect: () => {
                  grass *= 0.7;
                  pademelons *= 0.85;
                  devils *= 0.95;
                  bandicoots *= 0.9;
                  showEventMessage("üî• Small bushfire affected the ecosystem", "#e74c3c");
                }
              },
              {
                name: "Devil Facial Tumor Disease",
                effect: () => {
                  const diseaseSeverity = Math.random() * 0.2 + 0.1;
                  devils *= (1 - diseaseSeverity);
                  showEventMessage(`ü¶† Devil disease outbreak affected ${Math.round(diseaseSeverity * 100)}% of population`, "#9b59b6");
                }
              },
              {
                name: "Drought",
                effect: () => {
                  targetRainfall *= 0.7;
                  showEventMessage("üíß Mild drought reducing rainfall", "#3498db");
                }
              },
              {
                name: "Flood",
                effect: () => {
                  grass *= 0.85;
                  pademelons *= 0.9;
                  showEventMessage("üåä Seasonal flooding affected low-lying areas", "#3498db");
                }
              },
              {
                name: "Heat Wave",
                effect: () => {
                  targetTemperature += 5;
                  showEventMessage("‚òÄÔ∏è Short heat wave affecting the ecosystem", "#f39c12");
                }
              }
            ];
            
            const event = events[Math.floor(Math.random() * events.length)];
            event.effect();
            disasterFrame = customFrameCount;
            
            const disasterObj = objectives.find(obj => obj.type === "disasters");
            if (disasterObj) {
              disasterObj.count = (disasterObj.count || 0) + 1;
            }
          }

          // Trigger narrative event
          function triggerNarrativeEvent() {
            const messages = [];
            
            if (grass > 1000) {
              messages.push("üåø Grass is thriving! Great growing conditions");
            } else if (grass < 200) {
              messages.push("‚ö†Ô∏è Grass is low - consider increasing rainfall or reducing grazing");
            }
            
            if (pademelons > 250) {
              messages.push("ü¶ò Pademelon population is booming! Devils should increase soon");
            } else if (pademelons < 40) {
              messages.push("ü¶ò Pademelons need help - check predation and food supply");
            }
            
            if (devils > 80) {
              messages.push("ü¶ä Devil population is high - they're controlling herbivores well");
            } else if (devils < 15) {
              messages.push("ü¶ä Low devil numbers - pademelons may overpopulate");
            }
            
            if (bandicoots > 150) {
              messages.push("üêæ Bandicoots are engineering the soil! Grass growth boosted");
            } else if (bandicoots < 25) {
              messages.push("üêæ Bandicoot numbers are low - soil health may suffer");
            }
            
            const predatorPreyRatio = pademelons / (devils + 1);
            if (predatorPreyRatio > 8) {
              messages.push("‚öñÔ∏è Too many pademelons per devil - predators need help");
            } else if (predatorPreyRatio < 3 && pademelons > 50) {
              messages.push("‚öñÔ∏è Good predator-prey balance!");
            }
            
            if (messages.length > 0) {
              showNarrativeMessage(messages[Math.floor(Math.random() * messages.length)]);
            } else {
              const encouragements = [
                "üå± Your ecosystem is developing nicely",
                "ü¶ã Biodiversity is increasing",
                "‚≠ê Keep up the good management!",
                "üåç A balanced ecosystem is emerging"
              ];
              showNarrativeMessage(encouragements[Math.floor(Math.random() * encouragements.length)]);
            }
          }

          // Check objectives and achievements
          function checkObjectives() {
            // Standard objectives
            objectives.forEach(obj => {
              if (obj.achieved) return;
              
              let isAchieved = false;
              switch(obj.type) {
                case "pademelons":
                  isAchieved = pademelons >= 150;
                  break;
                case "apex_stability":
                  isAchieved = devils >= 60 && grass > 300;
                  break;
                case "keystone_effect":
                  isAchieved = grass >= 300;
                  break;
                case "disasters":
                  isAchieved = (obj.count || 0) >= 5;
                  break;
                case "biodiversity":
                  isAchieved = biodiversityIndex > 0.6 && customFrameCount >= 500;
                  break;
              }
              
              if (isAchieved) {
                obj.achieved = true;
                points += obj.points;
                showAchievement(obj.description, obj.points);
              }
            });
            
            // Ongoing objectives
            ongoingObjectives.forEach(obj => {
              if (obj.achieved) return;
              
              let conditionMet = false;
              switch(obj.type) {
                case "grass":
                  conditionMet = obj.condition(grass);
                  break;
                case "devils":
                  conditionMet = devils > 50;
                  break;
                case "balanced":
                  conditionMet = grass > 400 && pademelons > 60 && devils > 25 && bandicoots > 30;
                  break;
              }
              
              if (conditionMet) {
                obj.target--;
                if (obj.target <= 0) {
                  obj.achieved = true;
                  points += obj.points;
                  showAchievement(obj.description, obj.points);
                }
              } else {
                if (obj.target < (obj.type === "balanced" ? 1500 : 800)) {
                  obj.target += 5;
                }
              }
            });
            
            checkAchievements();
          }

          // Check for achievement unlocks
          function checkAchievements() {
            achievements.forEach(achievement => {
              if (achievement.achieved) return;
              
              let achieved = false;
              
              if (achievement.description.includes("ongoing objectives")) {
                achieved = ongoingObjectives.every(obj => obj.achieved);
              } 
              else if (achievement.description.includes("devil population")) {
                achievement.frames = devils > 50 ? (achievement.frames || 0) + 1 : 0;
                achieved = (achievement.frames || 0) >= achievement.target;
              }
              else if (achievement.description.includes("bandicoot population")) {
                achieved = bandicoots >= achievement.target;
              }
              
              if (achieved) {
                achievement.achieved = true;
                points += achievement.points;
                showAchievement(achievement.description, achievement.points);
              }
            });
          }

          // Update ecosystem metrics
          function updateEcosystemMetrics() {
            const total = grass + pademelons + devils + bandicoots;
            if (total > 0) {
              const p1 = grass / total;
              const p2 = pademelons / total;
              const p3 = devils / total;
              const p4 = bandicoots / total;
              biodiversityIndex = 1 - (p1*p1 + p2*p2 + p3*p3 + p4*p4);
            }
            
            updateHealthDisplay();
          }

          // Update health display
          function updateHealthDisplay() {
            let healthStatusText = "Healthy";
            let healthPercentage = 100;
            let healthColor = "#2ecc71";
            
            if (grass < 50 || pademelons < 20 || devils < 5 || bandicoots < 10) {
              healthStatusText = "Critical";
              healthPercentage = 20;
              healthColor = "#e74c3c";
            } else if (biodiversityIndex < 0.4) {
              healthStatusText = "Unstable";
              healthPercentage = 40;
              healthColor = "#f39c12";
            } else if (biodiversityIndex < 0.7) {
              healthStatusText = "Stable";
              healthPercentage = 70;
              healthColor = "#3498db";
            }
            
            if (healthStatus) {
              healthStatus.style.width = `${healthPercentage}%`;
              healthStatus.style.background = healthColor;
            }
            if (healthText) {
              healthText.textContent = healthStatusText;
              healthText.style.color = healthColor;
            }
            
            const biodiversityElement = document.getElementById("biodiversityValue");
            if (biodiversityElement) {
              biodiversityElement.textContent = biodiversityIndex.toFixed(2);
            }
          }

          // Update species displays
          function updateSpeciesDisplays() {
            if (grassValue) grassValue.textContent = Math.round(grass);
            if (pademelonsValue) pademelonsValue.textContent = Math.round(pademelons);
            if (devilsValue) devilsValue.textContent = Math.round(devils);
            if (bandicootsValue) bandicootsValue.textContent = Math.round(bandicoots);
          }

          // Reset simulation
          function resetSim() {
            grass = 600;
            pademelons = 80;
            devils = 25;
            bandicoots = 40;
            
            grassParticles = [];
            pademelonParticles = [];
            devilParticles = [];
            bandicootParticles = [];
            
            customFrameCount = 0;
            lastFrameTime = performance.now();
            points = 0;
            ecosystemHealth = 100;
            biodiversityIndex = 0;
            
            objectives.forEach(obj => {
              obj.achieved = false;
              if (obj.type === "disasters") obj.count = 0;
            });
            
            ongoingObjectives.forEach(obj => {
              obj.achieved = false;
              obj.target = obj.type === "balanced" ? 1500 : 800;
            });
            
            achievements.forEach(ach => ach.achieved = false);
            
            if (chart) {
              chart.data.labels = [];
              chart.data.datasets.forEach(dataset => dataset.data = []);
              chart.update();
            }
            
            populationHistory = [];
            
            const rainfallSlider = document.getElementById("rainfall");
            const tempSlider = document.getElementById("temperature");
            const invasiveSlider = document.getElementById("invasiveSpecies");
            const humanSlider = document.getElementById("humanImpact");
            
            if (rainfallSlider) {
              rainfallSlider.value = 50;
              const valSpan = document.getElementById("rainfallValue");
              if (valSpan) valSpan.textContent = "50";
            }
            if (tempSlider) {
              tempSlider.value = 25;
              const valSpan = document.getElementById("temperatureValue");
              if (valSpan) valSpan.textContent = "25";
            }
            if (invasiveSlider) {
              invasiveSlider.value = 5;
              const valSpan = document.getElementById("invasiveSpeciesValue");
              if (valSpan) valSpan.textContent = "5";
            }
            if (humanSlider) {
              humanSlider.value = 2;
              const valSpan = document.getElementById("humanImpactValue");
              if (valSpan) valSpan.textContent = "2";
            }
            
            season = 0;
            targetRainfall = currentRainfall = seasonParams[season].rainfall;
            targetTemperature = currentTemperature = seasonParams[season].temperature;
            if (seasonDisplay) seasonDisplay.textContent = seasonParams[season].name;
            
            updateUI();
            updateSpeciesDisplays();
            updateHealthDisplay();
            
            showNarrativeMessage("üå± Ecosystem reset to balanced state");
          }

          // Draw visualization
          function drawVisualization() {
            p.background(showSeasons ? seasonParams[season].color : 240);
            drawEcosystem();
            drawParticles();
          }

          // Draw ecosystem
          function drawEcosystem() {
            drawFoodWeb();
            
            const spacing = p.width / 5;
            drawPopulationIndicator(spacing, p.height/2, grass, "#4CAF50", "Grass");
            drawPopulationIndicator(2 * spacing, p.height/2, pademelons, "#FF9800", "Pademelons");
            drawPopulationIndicator(3 * spacing, p.height/2, devils, "#F44336", "Devils");
            drawPopulationIndicator(4 * spacing, p.height/2, bandicoots, "#FFEB3B", "Bandicoots");
          }

          // Draw food web
          function drawFoodWeb() {
            p.strokeWeight(2);
            const spacing = p.width / 5;
            
            if (grass > 10 && pademelons > 5) {
              p.stroke(76, 175, 80, 150);
              p.line(spacing + 20, p.height/2, 2 * spacing - 20, p.height/2);
            }
            
            if (pademelons > 5 && devils > 2) {
              p.stroke(244, 67, 54, 150);
              p.line(2 * spacing + 20, p.height/2, 3 * spacing - 20, p.height/2);
            }
            
            if (bandicoots > 5 && devils > 2) {
              p.stroke(244, 67, 54, 100);
              p.line(4 * spacing - 20, p.height/2, 3 * spacing + 20, p.height/2);
            }
            
            if (bandicoots > 5 && grass > 10) {
              p.stroke(255, 235, 59, 150);
              p.drawingContext.setLineDash([5, 3]);
              p.line(4 * spacing - 20, p.height/2, spacing + 20, p.height/2);
              p.drawingContext.setLineDash([]);
            }
          }

          // Draw particles
          function drawParticles() {
            grassParticles.forEach(part => {
              p.fill(part.color[0], part.color[1], part.color[2], part.life/2);
              p.noStroke();
              p.ellipse(part.x, part.y, part.size);
            });
            
            pademelonParticles.forEach(part => {
              p.fill(part.color[0], part.color[1], part.color[2], part.life/2);
              p.noStroke();
              p.ellipse(part.x, part.y, part.size);
            });
            
            devilParticles.forEach(part => {
              p.fill(part.color[0], part.color[1], part.color[2], part.life/2);
              p.noStroke();
              p.ellipse(part.x, part.y, part.size);
            });
            
            bandicootParticles.forEach(part => {
              p.fill(part.color[0], part.color[1], part.color[2], part.life/2);
              p.noStroke();
              p.ellipse(part.x, part.y, part.size);
            });
          }

          // Draw population indicator
          function drawPopulationIndicator(x, y, population, color, label) {
            const size = p.map(population, 0, 1000, 20, 100);
            
            let r, g, b;
            if (color.startsWith('#')) {
              r = parseInt(color.slice(1,3), 16);
              g = parseInt(color.slice(3,5), 16);
              b = parseInt(color.slice(5,7), 16);
            } else {
              [r, g, b] = [0, 0, 0];
            }
            
            const healthOpacity = p.map(population, 0, 500, 50, 200);
            p.fill(r, g, b, healthOpacity);
            p.noStroke();
            p.ellipse(x, y, size);
            
            if (population > 0) {
              const pulseSize = size * (1 + 0.1 * Math.sin(p.frameCount * 0.05));
              p.fill(r, g, b, healthOpacity * 0.3);
              p.ellipse(x, y, pulseSize);
            }
            
            p.fill(0);
            p.textSize(12);
            p.textAlign(p.CENTER);
            p.text(`${label}: ${Math.round(population)}`, x, y + size/2 + 20);
          }

          // Update UI
          function updateUI() {
            if (pointsDisplay) pointsDisplay.textContent = points;
            updateObjectiveDisplay();
            
            if (points >= rangerBadgePoints && !rangerBadgeAchieved) {
              rangerBadgeAchieved = true;
              showRangerBadge();
            }
          }

          // Update objective display
          function updateObjectiveDisplay() {
            const nextObj = objectives.find(obj => !obj.achieved) || 
                            ongoingObjectives.find(obj => !obj.achieved);
            
            if (nextObj && objectiveDisplay) {
              objectiveDisplay.textContent = nextObj.description;
              
              let progress = 0;
              if (nextObj.type === "disasters") {
                progress = Math.round(((nextObj.count || 0) / nextObj.target) * 100);
              } else if (nextObj.target && nextObj.target !== nextObj.points) {
                const total = nextObj.type === "balanced" ? 1500 : 800;
                progress = Math.round(((total - nextObj.target) / total) * 100);
              }
              
              if (progressBar) progressBar.style.width = `${Math.min(100, progress)}%`;
              if (progressText) progressText.textContent = `${Math.min(100, progress)}% complete`;
            } else {
              if (objectiveDisplay) objectiveDisplay.textContent = "All objectives completed! Try for achievements.";
              if (progressBar) progressBar.style.width = "100%";
              if (progressText) progressText.textContent = "100% complete";
            }
          }

          // Show event message
          function showEventMessage(message, color) {
            if (disasterMessage) {
              const messageText = disasterMessage.querySelector('.message-text');
              if (messageText) messageText.textContent = message;
              disasterMessage.style.backgroundColor = color;
              disasterMessage.style.opacity = "1";
              
              setTimeout(() => {
                disasterMessage.style.opacity = "0";
              }, 3000);
            }
          }

          // Show narrative message
          function showNarrativeMessage(message) {
            const narrativeElement = document.createElement("div");
            narrativeElement.className = "narrative-message";
            narrativeElement.innerHTML = `<i class="fas fa-info-circle"></i> ${message}`;
            document.body.appendChild(narrativeElement);
            
            setTimeout(() => {
              narrativeElement.style.opacity = "0";
              setTimeout(() => narrativeElement.remove(), 1000);
            }, 5000);
          }

          // Show achievement
          function showAchievement(message, points) {
            const achievementElement = document.createElement("div");
            achievementElement.className = "achievement-message";
            achievementElement.innerHTML = `
              <div class="achievement-icon"><i class="fas fa-trophy"></i></div>
              <div class="achievement-content">
                <h3>Achievement Unlocked!</h3>
                <p>${message}</p>
                ${points > 0 ? `<div class="achievement-points">+${points} points</div>` : ''}
              </div>
            `;
            const achievementsContainer = document.getElementById("achievementsContainer");
            if (achievementsContainer) {
              achievementsContainer.prepend(achievementElement);
            }
            
            setTimeout(() => {
              achievementElement.style.opacity = "0";
              setTimeout(() => achievementElement.remove(), 1000);
            }, 5000);
          }

          // Show ranger badge
          function showRangerBadge() {
            const medalIcon = document.getElementById("medalIcon");
            const rangerBadge = document.getElementById("rangerBadge");
            if (medalIcon) medalIcon.style.display = "flex";
            if (rangerBadge) {
              rangerBadge.style.display = "flex";
              setTimeout(() => {
                rangerBadge.classList.add("show");
              }, 100);
            }
          }

          // Toggle pause
          function togglePause() {
            isPaused = !isPaused;
            const pauseBtn = document.getElementById("pauseButton");
            if (pauseBtn) {
              if (isPaused) {
                pauseBtn.innerHTML = '<i class="fas fa-play"></i> Resume';
                pauseBtn.classList.remove("btn-primary");
                pauseBtn.classList.add("btn-success");
              } else {
                pauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
                pauseBtn.classList.remove("btn-success");
                pauseBtn.classList.add("btn-primary");
              }
            }
          }

          // Toggle seasons
          function toggleSeasonsDisplay() {
            const toggle = document.getElementById("toggleSeasons");
            if (toggle) showSeasons = toggle.checked;
          }

          // Toggle disasters
          function toggleDisasters() {
            const toggle = document.getElementById("toggleDisasters");
            if (toggle) showDisasters = toggle.checked;
          }

          // Toggle grass limit
          function toggleGrassLimit() {
            const toggle = document.getElementById("toggleGrassLimit");
            if (toggle) grassLimitEnabled = toggle.checked;
          }
        };

        // Create p5 instance
        new p5(ecosystemSimulator, document.body);
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
          if (e.code === 'Space') {
            e.preventDefault();
            const pauseBtn = document.getElementById("pauseButton");
            if (pauseBtn) pauseBtn.click();
          }
        });
      }, 100); // Small delay to ensure DOM is fully loaded
    });
  </script>
